# Živá poloha vozidel MHD
V tomto (dočasně) posledním díle si vytvoříme aplikaci, která bude zobrazovat na mapě aktuální polohu vozidel IDS JMK.

## Úvod do kódování řetězců
 Řekneme-li řetězec, předpokládáme, že jde o textová data a musíme uvést i pojem kódování. Historicky totiž vzniklo několik nezávislých způsobů, jak pomocí posloupnosti bajtů kódovat text. Na základní anglické abecedě se vesměs všichni shodli, ale pro různé národní speciality, jako jsou háčky, čárky, kroužky a další havěť kolem písmen existovaly různé způsoby, jak je zakódovat do posloupnosti bajtů, které byly vzájemně více či méně nekompatibilní. Určitě jste se někdy potkali se souborem nebo webovou stránkou, které jste otevřeli a místo znaků s háčky a čárkami byly divné paznaky. V současné době je nejpoužívanější znakovou sadou [`Unicode`] v podobě [`utf-8`], která obsahuje valnou většinu znaků, se kterými se na světě můžete potkat a navíc řadu dalších symbolů, smajlíků a podobných, stále se však můžeme v našich krajích potkat s `iso8859-2` nebo `windows-1250`. Protože o stahovaném souboru dopředu nemůžeme s jistotou říct, v jakém kodování bude, ani to nemusí být textový soubor (a pak by byl s převedením na řetězec problém, protože některá kódování zakazují některé posloupnosti bajtů), vrátí se nám `QBytesArray` respektive `bytes` a je na nás, abychom si ho případně převedli na řetězec.


## Stahování dat z internetu
Dosud jsme měli všecha data , která jsme potřebovali v našich aplikacích, uložená lokálně. Máme-li ale zobrazovat živé polohy vozidel MHD, potřebujeme průběžně stahovat aktuální polohy vozidel z internetu a pak je v naší aplikaci zobrazovat. Možná z Pythonu znáte modul [`requests`](https://requests.readthedocs.io/en/master/), ale jeho použití by, stejně jako [v minulém díle použití `time.sleep()`](../06_countdown/), způsobilo, že během čekání na stažení souboru by aplikace nereagovala. Potřebujeme tedy nějakou knihovnu v Qt, která zvládne dělat operace se sítí *na pozadí* a v případě, že je hotovo (nebo nastane chyba), vydá signál, který zachytíme a zpracujeme. Takováto knihovna se nazývá [`QNetworkAccessManager`](https://doc.qt.io/qtforpython/PySide2/QtNetwork/QNetworkAccessManager.html?highlight=qnetworkaccessmanager#PySide2.QtNetwork.QNetworkAccessManager).

[`QNetworkAccessManager`] vesměs odpovídá modulu [`requests`] v Pythonu co se týká určení a způsobu použití. Jde o jednoduché vysokoúrovňové rozhraní na obvyklé činnosti okolo stahování dat z webu. Obvykle vytvoříme jeden `QNetworkManager` objekt a jemu pak předáváme jednotlivé požadavky na stažení souboru pomocí metody [`get`] a když je soubor stažený, je vyvolán signál [`finished`], který nám rovnou předá stažená data.

Metodě [`get`] musíme předat [`QNetworkRequest`] místo obyčejné URL. Toto zdánlivě složitější řešení má výhodu v možnosti přizpůsobení požadavku, pokud to potřebujeme, ale nám naštěstí stačí jen vytvořit objekt [`QNetworkRequest`] a při vytváření mu předat [`QUrl`]. S [`QUrl`] jsme se již potkali při nastavování, které QML se má použít jako grafické rozhraní. [`QUrl`] slouží jako kontejner na uschování umístění nějakého objektu, ať už v souborovém systému nebo někde na internetu. [`QUrl`] už konečně stačí jen předat řetězec s adresou, kterou chceme stáhnout. Naštěstí žádný z objektů, které vytvoříme, abychom mohli zavolat [`get`], si nemusíme dále pamatovat, takže lze vytváření zřetězit a zavolat `get` jako `network_manager.get(QNetworkRequest(QUrl(<url>)))`. Tím se na pozadí spustí stahování souboru ze zadané adresy a funkce okamžitě vrátí [`QNetworkReply`] reprezentující budoucí odpověď na náš dotaz. Tuto odpověď si však, protože stahujeme jen jeden soubor naráz a pokaždé ten stejný, také nemusíme pamatovat, protože po úspěšném stažení dostaneme tuto [`QNetworkReply`] jako parametr signálu `finished` oznamujícího nám, že data byla stažena.

Potřebujeme tedy vytvořit slot, který zpracuje stažená data a připojit ho k signálu `finished` od `QNetworkAccessManageru`. Tento slot dostane jako parametr [`QNetworkReply`], která v sobě drží kromě informací o stahování i samotná stažená data. Protože [`QNetworkReply`] dědí od [`QIODevice`], chová se jako otevřený soubor v Qt a stažená data z něj lze naráz přečíst pomocí metody [`readAll`]. Zde se opět projevuje, že pracujeme s Qt a nikoliv čistým Pythonem. Vrácená data proto nejsou typu [`bytes`], který bychom očekávali v Pythonu, ale jsou typu [`QByteArray`], který se v obdobných situacích využívá v Qt.

Abychom získali typ [`str`], tedy řetězec s obsahem staženého souboru, což je obvykle to, co se snažíme získat, je potřeba zavolat na objektu typu [`QByteArray`] metodu [`data`], která vrátí, v souladu s očekáváním a oproti tomu, co tvrdí dokumentace, objekt typu `bytes`. Typ `bytes` se využívá pro reprezentaci nějaké posloupnosti [bajtů], o kterých nevíme nic přesnějšího.

## Aktualizace dat v `AbstractItemModel`u


## Zdroje
  - [Network Programming with Qt](https://doc.qt.io/qt-5/qtnetwork-programming.html)
